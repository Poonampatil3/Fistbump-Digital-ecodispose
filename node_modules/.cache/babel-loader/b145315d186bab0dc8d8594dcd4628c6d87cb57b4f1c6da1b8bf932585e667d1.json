{"ast":null,"code":"import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n// Make sure your .env file has the API key\nif (!process.env.REACT_APP_GEMINI_API_KEY) {\n  console.error('Missing Gemini API key! Please add REACT_APP_GEMINI_API_KEY to your .env file');\n}\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\nexport const analyzeImage = async imageData => {\n  try {\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-2.5-flash\"\n    });\n\n    // Handle both base64 string and Blob/File objects\n    let base64Data;\n    if (typeof imageData === 'string' && imageData.startsWith('data:image')) {\n      base64Data = imageData.split(',')[1];\n    } else if (imageData instanceof Blob || imageData instanceof File) {\n      base64Data = await convertBlobToBase64(imageData);\n    } else {\n      throw new Error('Invalid image data format');\n    }\n    const imageParts = [{\n      inlineData: {\n        data: base64Data,\n        mimeType: \"image/jpeg\"\n      }\n    }];\n    const prompt = `Analyze this image and provide waste classification details in the following strict format:\n\n    Name: [name of the item]\n    Material: [Plastic/Glass/Paper/Metal/Organic/Hazardous]\n    Category: [type of waste]\n    BinColor: [Yellow/Blue/Green/Brown/Black/Red]\n    Tip: [disposal instructions]\n\n    Yellow bin is for plastic and metal\n    Blue bin is for paper and cardboard\n    Green bin is for glass\n    Brown bin is for organic waste\n    Black bin is for general waste\n    Red bin is for hazardous materials`;\n    const result = await model.generateContent([prompt, ...imageParts]);\n    const response = await result.response;\n    const text = response.text();\n\n    // Parse the response into structured data\n    const lines = text.split('\\n');\n    const data = {};\n    lines.forEach(line => {\n      if (line.includes(':')) {\n        const [key, value] = line.split(':').map(s => s.trim());\n        data[key.toLowerCase()] = value;\n      }\n    });\n\n    // Return structured data matching your app's format\n    return {\n      id: Date.now().toString(),\n      name: data.name || 'Unknown Item',\n      material: data.material || 'Unknown',\n      category: data.category || 'General Waste',\n      binColor: data.bincolor || 'Black',\n      tip: data.tip || 'Please dispose of properly'\n    };\n  } catch (error) {\n    console.error('Error analyzing image:', error);\n    throw error;\n  }\n};\n\n// Helper function to convert Blob to base64\nconst convertBlobToBase64 = blob => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64String = reader.result.split(',')[1];\n      resolve(base64String);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n};","map":{"version":3,"names":["GoogleGenerativeAI","process","env","REACT_APP_GEMINI_API_KEY","console","error","genAI","analyzeImage","imageData","model","getGenerativeModel","base64Data","startsWith","split","Blob","File","convertBlobToBase64","Error","imageParts","inlineData","data","mimeType","prompt","result","generateContent","response","text","lines","forEach","line","includes","key","value","map","s","trim","toLowerCase","id","Date","now","toString","name","material","category","binColor","bincolor","tip","blob","Promise","resolve","reject","reader","FileReader","onloadend","base64String","onerror","readAsDataURL"],"sources":["C:/Users/patil/Desktop/fistbump2-main/src/services/geminiService.js"],"sourcesContent":["import { GoogleGenerativeAI } from \"@google/generative-ai\";\r\n\r\n// Make sure your .env file has the API key\r\nif (!process.env.REACT_APP_GEMINI_API_KEY) {\r\n  console.error('Missing Gemini API key! Please add REACT_APP_GEMINI_API_KEY to your .env file');\r\n}\r\n\r\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\r\n\r\nexport const analyzeImage = async (imageData) => {\r\n  try {\r\n    const model = genAI.getGenerativeModel({ model: \"gemini-2.5-flash\" });\r\n    \r\n    // Handle both base64 string and Blob/File objects\r\n    let base64Data;\r\n    if (typeof imageData === 'string' && imageData.startsWith('data:image')) {\r\n      base64Data = imageData.split(',')[1];\r\n    } else if (imageData instanceof Blob || imageData instanceof File) {\r\n      base64Data = await convertBlobToBase64(imageData);\r\n    } else {\r\n      throw new Error('Invalid image data format');\r\n    }\r\n\r\n    const imageParts = [\r\n      {\r\n        inlineData: {\r\n          data: base64Data,\r\n          mimeType: \"image/jpeg\"\r\n        },\r\n      },\r\n    ];\r\n\r\n    const prompt = `Analyze this image and provide waste classification details in the following strict format:\r\n\r\n    Name: [name of the item]\r\n    Material: [Plastic/Glass/Paper/Metal/Organic/Hazardous]\r\n    Category: [type of waste]\r\n    BinColor: [Yellow/Blue/Green/Brown/Black/Red]\r\n    Tip: [disposal instructions]\r\n\r\n    Yellow bin is for plastic and metal\r\n    Blue bin is for paper and cardboard\r\n    Green bin is for glass\r\n    Brown bin is for organic waste\r\n    Black bin is for general waste\r\n    Red bin is for hazardous materials`;\r\n\r\n    const result = await model.generateContent([prompt, ...imageParts]);\r\n    const response = await result.response;\r\n    const text = response.text();\r\n\r\n    // Parse the response into structured data\r\n    const lines = text.split('\\n');\r\n    const data = {};\r\n    \r\n    lines.forEach(line => {\r\n      if (line.includes(':')) {\r\n        const [key, value] = line.split(':').map(s => s.trim());\r\n        data[key.toLowerCase()] = value;\r\n      }\r\n    });\r\n\r\n    // Return structured data matching your app's format\r\n    return {\r\n      id: Date.now().toString(),\r\n      name: data.name || 'Unknown Item',\r\n      material: data.material || 'Unknown',\r\n      category: data.category || 'General Waste',\r\n      binColor: data.bincolor || 'Black',\r\n      tip: data.tip || 'Please dispose of properly',\r\n    };\r\n  } catch (error) {\r\n    console.error('Error analyzing image:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Helper function to convert Blob to base64\r\nconst convertBlobToBase64 = (blob) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onloadend = () => {\r\n      const base64String = reader.result.split(',')[1];\r\n      resolve(base64String);\r\n    };\r\n    reader.onerror = reject;\r\n    reader.readAsDataURL(blob);\r\n  });\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}