{"ast":null,"code":"import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n// Make sure your .env file has the API key\nif (!process.env.REACT_APP_GEMINI_API_KEY) {\n  console.error('Missing Gemini API key! Please add REACT_APP_GEMINI_API_KEY to your .env file');\n}\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\nexport const analyzeImage = async imageData => {\n  try {\n    var _parsedResponse$recyc;\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-2.5-flash\"\n    });\n\n    // Convert base64 to Uint8Array\n    const base64Data = imageData.split(',')[1];\n    const binaryData = atob(base64Data);\n    const bytes = new Uint8Array(binaryData.length);\n    for (let i = 0; i < binaryData.length; i++) {\n      bytes[i] = binaryData.charCodeAt(i);\n    }\n    const imageParts = [{\n      inlineData: {\n        data: base64Data,\n        mimeType: \"image/jpeg\"\n      }\n    }];\n    const prompt = `You are a waste classification expert. Carefully analyze this image and identify the exact material and proper disposal method.\n\n    Focus on these key aspects:\n    1. Material Identification:\n       - Look for transparency, reflections, and surface texture\n       - Check for material markings or recycling symbols\n       - Note any distinctive features (e.g., glass shine, plastic flexibility, paper fiber texture)\n    \n    2. Specific Material Categories:\n       - Glass: Look for transparent, rigid, non-flexible material with smooth surface\n       - Plastic: Look for flexibility, manufacturing marks, seams\n       - Paper/Cardboard: Look for fiber texture, folds, matte finish\n       - Metal: Look for shine, rigidity, magnetic properties\n       - Organic: Look for natural/food materials\n    \n    Provide your analysis in this exact format:\n    Name: [specific item name]\n    Material: [Glass/Plastic/Paper/Metal/Organic/Hazardous]\n    Recyclable: [Yes/No]\n    Bin: [Blue/Yellow/Green/Brown/Black/Red] bin\n    Tip: [specific disposal instructions]\n\n    Remember:\n    - Glass goes in Green bin\n    - Plastic and metal go in Yellow bin\n    - Paper goes in Blue bin\n    - Organic waste goes in Brown bin\n    - Hazardous waste goes in Red bin\n    - Non-recyclable waste goes in Black bin`;\n    const result = await model.generateContent([prompt, ...imageParts]);\n    const response = await result.response;\n    const text = response.text();\n\n    // Parse response with material verification\n    const lines = text.split('\\n');\n    const parsedResponse = {};\n    lines.forEach(line => {\n      if (line.includes(':')) {\n        const [key, value] = line.split(':').map(str => str.trim());\n        parsedResponse[key.toLowerCase()] = value;\n      }\n    });\n\n    // Material-specific verification\n    const verifyMaterialAndBin = (material, binColor) => {\n      const materialBinMap = {\n        'glass': 'Green',\n        'plastic': 'Yellow',\n        'metal': 'Yellow',\n        'paper': 'Blue',\n        'cardboard': 'Blue',\n        'organic': 'Brown',\n        'hazardous': 'Red'\n      };\n      const materialLower = material.toLowerCase();\n      for (const [key, color] of Object.entries(materialBinMap)) {\n        if (materialLower.includes(key)) {\n          return {\n            material,\n            binColor: color\n          };\n        }\n      }\n      return {\n        material,\n        binColor: 'Black'\n      }; // Default to general waste\n    };\n    const {\n      material,\n      binColor\n    } = verifyMaterialAndBin(parsedResponse.material || \"Unknown\", parsedResponse.bin ? parsedResponse.bin.split(' ')[0] : \"Black\");\n    return {\n      name: parsedResponse.name || \"Unknown Item\",\n      material: material,\n      category: ((_parsedResponse$recyc = parsedResponse.recyclable) === null || _parsedResponse$recyc === void 0 ? void 0 : _parsedResponse$recyc.toLowerCase()) === 'yes' ? 'Recyclables' : 'General Waste',\n      binColor: binColor,\n      tip: parsedResponse.tip || \"Please dispose of according to local guidelines\"\n    };\n  } catch (error) {\n    console.error('Error analyzing image:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["GoogleGenerativeAI","process","env","REACT_APP_GEMINI_API_KEY","console","error","genAI","analyzeImage","imageData","_parsedResponse$recyc","model","getGenerativeModel","base64Data","split","binaryData","atob","bytes","Uint8Array","length","i","charCodeAt","imageParts","inlineData","data","mimeType","prompt","result","generateContent","response","text","lines","parsedResponse","forEach","line","includes","key","value","map","str","trim","toLowerCase","verifyMaterialAndBin","material","binColor","materialBinMap","materialLower","color","Object","entries","bin","name","category","recyclable","tip"],"sources":["C:/Users/patil/Desktop/fistbump2-main/src/services/geminiService.js"],"sourcesContent":["import { GoogleGenerativeAI } from \"@google/generative-ai\";\r\n\r\n// Make sure your .env file has the API key\r\nif (!process.env.REACT_APP_GEMINI_API_KEY) {\r\n  console.error('Missing Gemini API key! Please add REACT_APP_GEMINI_API_KEY to your .env file');\r\n}\r\n\r\nconst genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY || '');\r\n\r\nexport const analyzeImage = async (imageData) => {\r\n  try {\r\n    const model = genAI.getGenerativeModel({ model: \"gemini-2.5-flash\" });\r\n    \r\n    // Convert base64 to Uint8Array\r\n    const base64Data = imageData.split(',')[1];\r\n    const binaryData = atob(base64Data);\r\n    const bytes = new Uint8Array(binaryData.length);\r\n    for (let i = 0; i < binaryData.length; i++) {\r\n      bytes[i] = binaryData.charCodeAt(i);\r\n    }\r\n\r\n    const imageParts = [\r\n      {\r\n        inlineData: {\r\n          data: base64Data,\r\n          mimeType: \"image/jpeg\"\r\n        },\r\n      },\r\n    ];\r\n\r\n    const prompt = `You are a waste classification expert. Carefully analyze this image and identify the exact material and proper disposal method.\r\n\r\n    Focus on these key aspects:\r\n    1. Material Identification:\r\n       - Look for transparency, reflections, and surface texture\r\n       - Check for material markings or recycling symbols\r\n       - Note any distinctive features (e.g., glass shine, plastic flexibility, paper fiber texture)\r\n    \r\n    2. Specific Material Categories:\r\n       - Glass: Look for transparent, rigid, non-flexible material with smooth surface\r\n       - Plastic: Look for flexibility, manufacturing marks, seams\r\n       - Paper/Cardboard: Look for fiber texture, folds, matte finish\r\n       - Metal: Look for shine, rigidity, magnetic properties\r\n       - Organic: Look for natural/food materials\r\n    \r\n    Provide your analysis in this exact format:\r\n    Name: [specific item name]\r\n    Material: [Glass/Plastic/Paper/Metal/Organic/Hazardous]\r\n    Recyclable: [Yes/No]\r\n    Bin: [Blue/Yellow/Green/Brown/Black/Red] bin\r\n    Tip: [specific disposal instructions]\r\n\r\n    Remember:\r\n    - Glass goes in Green bin\r\n    - Plastic and metal go in Yellow bin\r\n    - Paper goes in Blue bin\r\n    - Organic waste goes in Brown bin\r\n    - Hazardous waste goes in Red bin\r\n    - Non-recyclable waste goes in Black bin`;\r\n\r\n    const result = await model.generateContent([prompt, ...imageParts]);\r\n    const response = await result.response;\r\n    const text = response.text();\r\n\r\n    // Parse response with material verification\r\n    const lines = text.split('\\n');\r\n    const parsedResponse = {};\r\n    \r\n    lines.forEach(line => {\r\n      if (line.includes(':')) {\r\n        const [key, value] = line.split(':').map(str => str.trim());\r\n        parsedResponse[key.toLowerCase()] = value;\r\n      }\r\n    });\r\n\r\n    // Material-specific verification\r\n    const verifyMaterialAndBin = (material, binColor) => {\r\n      const materialBinMap = {\r\n        'glass': 'Green',\r\n        'plastic': 'Yellow',\r\n        'metal': 'Yellow',\r\n        'paper': 'Blue',\r\n        'cardboard': 'Blue',\r\n        'organic': 'Brown',\r\n        'hazardous': 'Red'\r\n      };\r\n\r\n      const materialLower = material.toLowerCase();\r\n      for (const [key, color] of Object.entries(materialBinMap)) {\r\n        if (materialLower.includes(key)) {\r\n          return { material, binColor: color };\r\n        }\r\n      }\r\n      return { material, binColor: 'Black' }; // Default to general waste\r\n    };\r\n\r\n    const { material, binColor } = verifyMaterialAndBin(\r\n      parsedResponse.material || \"Unknown\",\r\n      parsedResponse.bin ? parsedResponse.bin.split(' ')[0] : \"Black\"\r\n    );\r\n\r\n    return {\r\n      name: parsedResponse.name || \"Unknown Item\",\r\n      material: material,\r\n      category: parsedResponse.recyclable?.toLowerCase() === 'yes' ? 'Recyclables' : 'General Waste',\r\n      binColor: binColor,\r\n      tip: parsedResponse.tip || \"Please dispose of according to local guidelines\",\r\n    };\r\n  } catch (error) {\r\n    console.error('Error analyzing image:', error);\r\n    throw error;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}